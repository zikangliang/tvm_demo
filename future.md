# TVM Demo - 未来发展规划

本文档记录项目从当前实现到完整架构的演进路径。

---

## 当前状态

| 项目 | 状态 |
|------|------|
| **调度方式** | BSP 分层调度（9层静态表） |
| **算子数量** | 15 种（6种基础 + 4种激活 + 3种基础运算 + 2种常量） |
| **数据结构** | 静态调度表，手写依赖关系 |
| **并行支持** | Worker 线程池 + 屏障同步 |
| **测试验证** | 回归测试 + 单元测试（14项） |
| **单元测试** | `make test` 一键运行 |

### 已完成算子（2026-01-15）

| 类别 | 算子 | 状态 |
|------|------|------|
| **基础** | add, subtract (6变体) | ✅ |
| **激活** | ReLU, Sigmoid, Tanh, ReLU6 | ✅ |
| **运算** | Multiply, Maximum, Minimum | ✅ |
| **常量** | Mul2, MulHalf | ✅ |

---

## 发展方向

### 方向一：实现就绪队列调度

**⚠️ 重要警告**：此方向存在**内存冲突**风险，详见下文"挑战"部分。

**目标**：从静态 BSP 升级为动态就绪队列驱动，实现文档方案三。

**核心差异**：
| 特性 | 当前 BSP | 目标（就绪队列） |
|------|----------|------------------|
| 调度驱动 | 静态分层表 | 动态就绪队列 |
| 依赖解析 | 编译期确定 | 运行时 dep_count |
| 并行度 | 固定（每层预设） | 自适应（任意就绪算子） |
| 计算图 | 隐式（分层表） | 显式 DAG（邻接表） |
| **内存安全** | **编译期保证** | **需运行时机制** |

#### 挑战：内存冲突问题

**当前 BSP 的优势**：
- 每一层的算子输出映射到**不同的内存槽**
- 编译期可以分析并保证同一层内无冲突
- 层间有屏障同步，复用安全

```c
// Layer 1 (4并行): Op0→M0, Op1→M1, Op2→M2, Op3→M3  ← 4个不同槽
// Layer 2 (2并行): Op4→M4, Op5→M5                      ← 2个不同槽
// Layer 3 (2并行): Op6→M0, Op7→M1                      ← 复用，但L1已结束
```

**就绪队列的风险**：
- 哪些算子同时执行是**运行时决定**的
- 无法预先保证同时执行的算子输出不冲突
- 需要额外的冲突检测/动态分配机制

**可能的解决方案**（各有代价）：

| 方案 | 缺点 |
|------|------|
| 运行时冲突检测 | 每个算子执行前检查，性能损失 |
| 保守分配（不复用） | 内存浪费 |
| 每个槽加锁 | 严重限制并行度 |
| 单调度线程 | 调度线程成为瓶颈 |

#### 实现路径（如决定实现）

1. 定义 DAG 数据结构
   ```c
   typedef struct {
       tvmrt_op_desc_t* ops;
       uint32_t* adj_list;      // 邻接表
       uint32_t* adj_offset;    // 邻接表偏移
       uint32_t* dep_count;     // 每个算子入边数
   } tvmrt_graph_t;
   ```

2. 实现拓扑排序（初始化 dep_count）

3. 实现就绪队列 + 内存安全机制
   - 线程安全队列
   - 内存槽占用表或锁机制

4. Worker 调度逻辑

5. 替换 `tvmrt_engine_run_*()` 入口

#### 预期收益与代价

**收益**：
- 支持任意 DAG 结构
- 更灵活的并行度利用

**代价**：
- 并发控制复杂度大幅上升
- 内存效率可能下降
- 调试难度增加

---

### 方向二：DAG → 静态表自动生成工具

**目标**：解决当前 `model_data.c` 手写调度表的维护痛点。

**问题**：
- 当前 16 算子 / 9 层是人工计算的
- 新增算子需要重新分析依赖、手动分层
- 容易出错，难以扩展

**方案**：
开发离线工具，输入 DAG 描述，输出静态调度表。

**输入格式（示例）**：
```json
{
  "tensors": [
    {"id": "input", "shape": [1]},
    {"id": "const_1", "value": 1.0},
    {"id": "t0", "storage": "M0"}
  ],
  "operators": [
    {"name": "add", "inputs": ["input", "const_1"], "outputs": ["t0"]},
    {"name": "add", "inputs": ["input", "const_3"], "outputs": ["t1"]}
  ]
}
```

**输出**：C 代码静态调度表

**实现选项**：
- Python 快速原型（推荐）
- C 工具（集成到项目）
- TVM Pass 集成（长期）

---

### 方向三：扩充算子库

**目标**：从演示级算子扩展到实用级算子。

**已完成**（2026-01-15）：
- ✅ 基础：add, subtract (6 变体)
- ✅ 激活：ReLU, Sigmoid, Tanh, ReLU6
- ✅ 运算：Multiply, Maximum, Minimum
- ✅ 常量：Mul2, MulHalf

**后续规划**：

| 类别 | 算子 | 优先级 |
|------|------|--------|
| **基础** | 除法、绝对值、取负 | 中 |
| **激活** | LeakyReLU, ELU, Swish | 低 |
| **归约** | Sum, Max, Min, ArgMax | 中 |
| **线性** | MatMul, FullyConnected | 高 |
| **卷积** | Conv2D (简单版) | 低 |
| **池化** | MaxPool, AvgPool | 低 |

**注意**：扩充算子前应优先完善调度架构，否则只是"量的堆砌"。

---

### 方向四：异构加速支持

**目标**：为 DSP/NPU 等加速器预留接口。

**设计**：
```c
typedef enum {
    DEVICE_CPU,
    DEVICE_DSP,
    DEVICE_NPU,
} tvmrt_device_t;

typedef struct {
    tvmrt_device_t device;
    int32_t (*func)(void*);  // 设备特定执行函数
} tvmrt_op_exec_t;
```

**实现**：
- 设备抽象层
- 内存拷贝/同步机制
- 设备调度策略

---

### 方向五：自动化测试框架

**目标**：从单一测试扩展到系统化测试。

**测试类型**：

1. **正确性测试**
   - 随机 DAG 生成器
   - 与参考实现比对结果

2. **性能测试**
   - 不同并行度下的吞吐量
   - 调度开销统计

3. **压力测试**
   - 大规模计算图（100+ 算子）
   - 极端依赖链/扇出场景

---

### 方向六：文档与示例

**目标**：降低使用门槛。

**内容**：
- 架构设计文档（API 说明）
- 添加自定义算子指南
- 移植指南（RTOS 适配）
- 性能调优建议

---

## 建议优先级（已更新）

| 优先级 | 方向 | 状态 | 理由 |
|--------|------|------|------|
| **P0** | DAG → 静态表工具 | 待开发 | 提升可维护性，保留BSP优势 |
| **P1** | 自动化测试框架 | 部分完成 | 单元测试已建立，需扩展 |
| **P1** | 扩充算子库 | ✅ 已完成基础 | 激活/基础运算已实现 |
| **P2** | 文档完善 | 持续更新 | 降低使用门槛 |
| **P3** | 就绪队列调度 | 待评估 | 复杂度高，收益有限 ⚠️ |
| **P3** | 异构加速 | 待开发 | 高级特性 |

**说明**：由于 BSP 分层调度在内存安全性上有天然优势（编译期保证无冲突），建议优先完善 BSP 工具链而非盲目升级到就绪队列。

---

## 参考

- 设计文档：`docs/guide/方案评审1212_v0.8.pdf`
- 工作记录：`src/Initial/work.md`
- 开发记录：[docs/updates/](./docs/updates/) - 算子扩展等开发日志

---

**最后更新**: 2026-01-15
